# 跨分类移动功能

## 功能概述

在编辑模式下，支持将卡片移动到任意主菜单或子菜单分类中，同时保持原有页面布局不变，实现丝滑、直观的卡片管理体验。

## 主要特性

### 1. 保持原有布局
- **普通模式**：正常浏览，展示当前选中的分类
- **编辑模式**：不改变页面结构，仍然只显示当前分类
- 保证用户体验一致性，不会因编辑模式而感到困惑

### 2. 目标分类选择器
- 点击卡片的“移动”按钮，弹出目标分类选择面板
- 显示所有可用的主菜单和子菜单
- 点击目标分类即可移动卡片
- 支持动态菜单：自动检测新增的菜单

### 3. 内部拖动排序
- 在当前分类内，仍然支持拖动排序
- 使用 Sortable.js 实现流畅的拖动效果
- 拖动完成后自动保存新顺序

### 4. 视觉反馈
- 选择面板以渐入动画显示
- 当前分类在选择器中高亮显示
- 移动成功后给予提示反馈

## 使用方法

### 进入编辑模式
1. 点击浮动按钮菜单中的“编辑模式”按钮
2. 输入管理员密码验证
3. 验证成功后，进入编辑模式（页面布局不变）

### 移动卡片到其他分类
1. 在编辑模式下，点击卡片右上角的“移动”按钮（👉）
2. 右侧弹出目标分类选择面板
3. 点击任意主菜单或子菜单
4. 卡片自动移动并保存

### 分类内排序
1. 在编辑模式下，直接拖动卡片
2. 放到目标位置，自动保存新顺序

### 其他操作
- **编辑卡片**：点击卡片右上角的编辑按钮（✏️）
- **删除卡片**：点击卡片右上角的删除按钮（🗑️）
- **退出编辑**：点击浮动菜单中的“退出编辑模式”按钮

## 技术实现

### 前端组件
- **Home.vue**：负责数据加载、视图切换、事件处理
- **CardGrid.vue**：负责渲染卡片、初始化拖动、触发事件

### 关键函数

#### Home.vue
```javascript
// 加载所有分类的卡片（编辑模式）
async function loadAllCards()

// 根据分类ID获取卡片
function getCategoryCards(menuId, subMenuId)

// 处理卡片排序更新
async function handleCardsReordered(cardIds, targetMenuId, targetSubMenuId)
```

#### CardGrid.vue
```javascript
// 初始化拖动功能
function initSortable()

// Props 新增
- categoryId: Number         // 当前分类ID
- subCategoryId: Number|null // 当前子分类ID
```

### 数据流
1. 用户拖动卡片
2. Sortable.js 触发 `onEnd` 事件
3. CardGrid emit `cardsReordered` 事件，传递卡片ID列表和目标分类ID
4. Home 接收事件，调用批量更新 API
5. 更新成功后重新加载所有分类数据

## 注意事项

1. **最小修改原则**：
   - 保留了普通模式的原有功能
   - 编辑模式仅新增展示方式，不影响其他功能
   - 拖动逻辑独立，不影响其他操作

2. **性能优化**：
   - 只在进入编辑模式时加载所有分类数据
   - 使用卡片ID而非完整对象传递数据
   - 拖动操作自动批量更新，减少请求次数

3. **用户体验**：
   - 静默保存，减少打扰
   - 失败时自动恢复，保证数据一致性
   - 视觉提示清晰，操作直观

## 样式说明

### 分类容器
- 半透明白色背景，毛玻璃效果
- 圆角边框，阴影效果
- 响应式布局适配移动端

### 空分类提示
- 虚线边框
- 半透明文字提示
- 自动显示在空分类底部

## 浏览器兼容性

- Chrome/Edge 90+
- Firefox 88+
- Safari 14+
- 移动端浏览器支持

## 已修复的问题

### 问题 1：全局选择器冲突（已修复）

**现象**：
- 只有第一个分类可以拖动
- 其他分类内部无法拖动排序
- 无法跨分类拖动

**原因**：
```javascript
// 错误的实现：使用全局选择器
const container = document.querySelector('.card-grid');
// 所有 CardGrid 组件实例都选中了第一个 .card-grid 元素
```

当多个 CardGrid 组件同时渲染时：
1. 每个组件都尝试初始化 Sortable
2. 但它们都使用 `document.querySelector('.card-grid')`
3. 这个选择器只会返回 **第一个** 匹配的元素
4. 结果：所有 Sortable 实例都绑定在同一个 DOM 上

**修复方案**：
```javascript
// 正确的实现：使用组件内部的 ref
<template>
  <div ref="cardGridRef" class="container card-grid">
    <!-- ... -->
  </div>
</template>

<script setup>
const cardGridRef = ref(null);

function initSortable() {
  const container = cardGridRef.value; // 使用组件自己的 ref
  // ...
}
</script>
```

**效果**：
- 每个 CardGrid 组件都有自己的 ref 引用
- 每个 Sortable 实例绑定在正确的容器上
- 所有分类都可以独立拖动
- 支持跨分类拖动

## 已知限制

1. 不支持 IE 浏览器
2. 拖动动画在移动端可能不够流畅
3. 大量卡片时加载可能需要时间

## 未来改进

- [ ] 支持批量拖动多个卡片
- [ ] 添加拖动撤销/重做功能
- [ ] 优化移动端拖动体验
- [ ] 添加拖动操作的历史记录
